> GENERATED BY CHATGPT!

下面直接给出 **可立即运行** 的三份文件 + 依赖清单与简要启动说明。假设你选 M1（`metadata.csv` 包含 `filename,title,authors,year`），PDF 按 `papers/<CONF>/<NAME>.pdf` 组织（P2），脚本会同时使用路径解析 `conference` 字段并以 CSV 为准覆盖元数据。

---

# 1) `import_pdfs.py` — 批量抽文本并导入 Meilisearch（支持 pdftotext 或 pdfminer 退路）

```python
#!/usr/bin/env python3
"""
import_pdfs.py
- Scan papers_dir for PDFs (recursively).
- Read metadata.csv (format: filename,title,authors,year) where filename is relative path under papers_dir (e.g., ICML2023/Transformer.pdf)
- Extract text (pdftotext if available, otherwise pdfminer.six).
- Build JSON docs and push to Meilisearch in batches.
Usage:
  python import_pdfs.py --papers papers --metadata metadata.csv --meili http://localhost:7700 --key admin123 --index papers
"""
import os
import sys
import csv
import argparse
import subprocess
import json
import glob
from pathlib import Path
from tqdm import tqdm
import requests

BATCH_SIZE = 100

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument("--papers", required=True, help="Root folder containing PDFs (recursive)")
    p.add_argument("--metadata", required=True, help="CSV file: filename,title,authors,year")
    p.add_argument("--meili", default="http://127.0.0.1:7700", help="Meilisearch URL")
    p.add_argument("--key", default="", help="Meilisearch master key")
    p.add_argument("--index", default="papers", help="Meilisearch index uid")
    return p.parse_args()

def load_metadata(csv_path):
    meta = {}
    with open(csv_path, newline='', encoding='utf8') as f:
        rdr = csv.DictReader(f)
        required = {"filename","title","authors","year"}
        if not required.issubset(set(rdr.fieldnames)):
            raise SystemExit(f"metadata.csv must contain columns: {required}")
        for r in rdr:
            key = r["filename"].strip()
            meta[key] = {
                "title": r["title"].strip(),
                "authors": r["authors"].strip(),
                "year": r["year"].strip()
            }
    return meta

def extract_text_pdftotext(pdf_path):
    txt_path = str(pdf_path) + ".txt.tmp"
    try:
        subprocess.check_call(["pdftotext", "-layout", str(pdf_path), txt_path], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        with open(txt_path, "r", encoding="utf8", errors="ignore") as f:
            txt = f.read()
        os.remove(txt_path)
        return txt
    except Exception:
        if os.path.exists(txt_path):
            os.remove(txt_path)
        return None

def extract_text_pdfminer(pdf_path):
    # fallback using pdfminer.six (needs to be installed)
    try:
        from io import StringIO
        from pdfminer.high_level import extract_text
        text = extract_text(str(pdf_path))
        return text
    except Exception:
        return None

def extract_text(pdf_path):
    txt = extract_text_pdftotext(pdf_path)
    if txt and txt.strip():
        return txt
    txt = extract_text_pdfminer(pdf_path)
    if txt:
        return txt
    return ""

def make_doc(pdf_root: Path, pdf_path: Path, metadata_map):
    rel = str(pdf_path.relative_to(pdf_root)).replace("\\","/")
    # conference from first segment of relative path if exists
    parts = rel.split("/")
    conference = parts[0] if len(parts) > 1 else ""
    meta = metadata_map.get(rel, {})
    title = meta.get("title", pdf_path.stem)
    authors = meta.get("authors", "")
    year = meta.get("year", "")
    text = extract_text(pdf_path)
    return {
        "id": rel,
        "path": rel,
        "conference": conference,
        "title": title,
        "authors": authors,
        "year": year,
        "text": text
    }

def ensure_index(meili_url, key, index_uid):
    hdr = {}
    if key:
        hdr["Authorization"] = f"Bearer {key}"
    # create index (ignore if exists)
    url = f"{meili_url.rstrip('/')}/indexes"
    payload = {"uid": index_uid}
    r = requests.post(url, headers=hdr, json=payload)
    # set settings for searchable & faceting
    settings_url = f"{meili_url.rstrip('/')}/indexes/{index_uid}/settings"
    settings = {
        "searchableAttributes": ["title","authors","text","conference"],
        "displayedAttributes": ["title","authors","year","conference","path","_formatted"],
        "attributesForFaceting": ["conference","year"]
    }
    requests.post(settings_url, headers=hdr, json=settings)

def push_batch(meili_url, key, index_uid, docs):
    hdr = {"Content-Type":"application/json"}
    if key:
        hdr["Authorization"] = f"Bearer {key}"
    url = f"{meili_url.rstrip('/')}/indexes/{index_uid}/documents"
    r = requests.post(url, headers=hdr, data=json.dumps(docs))
    if not r.ok:
        print("ERROR pushing batch:", r.status_code, r.text)
    return r

def main():
    args = parse_args()
    papers_root = Path(args.papers)
    if not papers_root.exists():
        raise SystemExit("papers folder not found")
    metadata_map = load_metadata(args.metadata)
    pdf_paths = [Path(p) for p in glob.glob(os.path.join(args.papers, "**", "*.pdf"), recursive=True)]
    print(f"Found {len(pdf_paths)} pdf files under {args.papers}")
    ensure_index(args.meili, args.key, args.index)
    batch = []
    for p in tqdm(pdf_paths):
        doc = make_doc(papers_root, p, metadata_map)
        batch.append(doc)
        if len(batch) >= BATCH_SIZE:
            push_batch(args.meili, args.key, args.index, batch)
            batch = []
    if batch:
        push_batch(args.meili, args.key, args.index, batch)
    print("Done. Documents imported.")

if __name__ == "__main__":
    main()
```

---

# 2) `search_app.py` — Flask 后端渲染的 Scholar 风格检索界面

```python
#!/usr/bin/env python3
"""
search_app.py - Minimal Flask app that queries Meilisearch and shows results.
Usage:
  export MEILI_URL=http://127.0.0.1:7700
  export MEILI_KEY=admin123
  export MEILI_INDEX=papers
  FLASK_APP=search_app.py flask run --host=0.0.0.0 --port=5000
"""
from flask import Flask, render_template, request
import os
import requests

app = Flask(__name__)
MEILI_URL = os.environ.get("MEILI_URL", "http://127.0.0.1:7700").rstrip("/")
MEILI_KEY = os.environ.get("MEILI_KEY", "")
MEILI_INDEX = os.environ.get("MEILI_INDEX", "papers")

HEADERS = {"Content-Type":"application/json"}
if MEILI_KEY:
    HEADERS["Authorization"] = f"Bearer {MEILI_KEY}"

@app.route("/", methods=["GET"])
def index():
    q = request.args.get("q", "").strip()
    page = int(request.args.get("page", "1"))
    per_page = 10
    results = {"hits":[], "nbHits":0}
    if q:
        body = {
            "q": q,
            "offset": (page-1)*per_page,
            "limit": per_page,
            "attributesToHighlight": ["text"],
            "attributesToCrop": ["text"],
            "cropLength": 250
        }
        url = f"{MEILI_URL}/indexes/{MEILI_INDEX}/search"
        r = requests.post(url, headers=HEADERS, json=body)
        if r.ok:
            results = r.json()
        else:
            results = {"hits":[], "nbHits":0, "error": r.text}
    return render_template("index.html", q=q, results=results, page=page, per_page=per_page)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
```

---

# 3) `templates/index.html` — 简洁 Bootstrap 页面（放在 `templates/` 目录）

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Paper Search</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    .snippet { white-space: pre-wrap; }
    .meta { font-size: 0.9rem; color: #555; }
  </style>
</head>
<body class="bg-light">
  <div class="container py-4">
    <h3>Paper Search</h3>
    <form method="get" class="mb-3">
      <div class="input-group">
        <input class="form-control" name="q" placeholder="search..." value="{{ q|e }}">
        <button class="btn btn-primary" type="submit">Search</button>
      </div>
    </form>

    {% if q %}
      <p class="text-muted">Results for "<strong>{{ q|e }}</strong>" — {{ results.nbHits }} hits</p>
      {% for h in results.hits %}
        <div class="card mb-2">
          <div class="card-body">
            <h5 class="card-title mb-1">{{ h.title }}</h5>
            <div class="meta mb-2">
              {{ h.authors }} {% if h.year %} • {{ h.year }}{% endif %} {% if h.conference %} • {{ h.conference }}{% endif %}
              <span class="float-end"><a href="/static/papers/{{ h.path }}" target="_blank">Open PDF</a></span>
            </div>
            {% if h._formatted and h._formatted.text %}
              <p class="snippet">{{ h._formatted.text|safe }}</p>
            {% else %}
              <p class="snippet">{{ h.text[:500] }}{% if h.text|length > 500 %}...{% endif %}</p>
            {% endif %}
          </div>
        </div>
      {% endfor %}

      <!-- simple pager -->
      <nav aria-label="pager">
        <ul class="pagination">
          {% if page>1 %}
            <li class="page-item"><a class="page-link" href="?q={{ q }}&page={{ page-1 }}">Previous</a></li>
          {% endif %}
          <li class="page-item disabled"><a class="page-link">Page {{ page }}</a></li>
          {% if results.nbHits > page*per_page %}
            <li class="page-item"><a class="page-link" href="?q={{ q }}&page={{ page+1 }}">Next</a></li>
          {% endif %}
        </ul>
      </nav>
    {% else %}
      <p class="text-muted">Enter query above. Index: <strong>{{ config.get('MEILI_INDEX', 'papers') }}</strong></p>
    {% endif %}
  </div>
</body>
</html>
```

> 注意：`Open PDF` 链接假设你把 `papers/` 文件夹通过 Flask 的静态目录或反向代理公开为 `/static/papers/...`。下面的 README 说明如何做。

---

# 4) `requirements.txt`

```
Flask>=2.0
requests>=2.0
tqdm
pdfminer.six   # fallback (optional if you have pdftotext)
```

`pdftotext`（poppler-utils）建议安装在系统上以获得最好效果：Debian/Ubuntu: `sudo apt install poppler-utils`。若无 root，你可在机器上用包管理或将 pdfminer.six 用作退路。

---

# 5) 简要 README（启动步骤 — 最精简）

1. 启动 Meilisearch（示例 rootless）：

```bash
# 直接二进制
./meilisearch --http-addr "0.0.0.0:7700" --master-key "admin123"
# 或 docker (rootless)
docker run -d -p 7700:7700 -e MEILI_MASTER_KEY=admin123 getmeili/meilisearch:v1.8
```

2. 准备文件结构（示例）：

```
project/
  papers/
    ICML2023/Transformer.pdf
    NeurIPS2022/SomePaper.pdf
  metadata.csv   # columns: filename,title,authors,year
  import_pdfs.py
  search_app.py
  templates/index.html
```

`metadata.csv` 示例行：

```
filename,title,authors,year
ICML2023/Transformer.pdf,Attention is All You Need,"Vaswani, Shazeer",2017
NeurIPS2022/SomePaper.pdf,My Paper,"A Author; B Author",2022
```

3. 导入数据：

```bash
python3 -m pip install -r requirements.txt
python import_pdfs.py --papers papers --metadata metadata.csv --meili http://127.0.0.1:7700 --key admin123 --index papers
```

4. 部署 Flask 前端：

```bash
export MEILI_URL=http://127.0.0.1:7700
export MEILI_KEY=admin123
export MEILI_INDEX=papers
# serve PDFs over static route - option A: symlink/copy papers into `static/papers`
mkdir -p static
ln -s $(realpath papers) static/papers

# run
flask run --host=0.0.0.0 --port=5000
# open http://<host>:5000
```

5. 安全 & 多用户（建议）：

* 在内网环境，至少用 Nginx 或 Caddy 做反向代理并启用 HTTP BasicAuth 或公司 SSO。不要把 Meilisearch master key 公开在前端代码 — 用后端（Flask）代为请求 Meilisearch，或在代理层对外做认证。

---

# 额外说明（快速要点）

* 脚本会以 `filename`（相对于 `papers/`）作为 `id` 与 `path`（例如 `ICML2023/Transformer.pdf`）。CSV 中 `filename` 必须匹配这一相对路径。
* 优先使用 `pdftotext`（更快更准确的布局）；若不可用，脚本会使用 `pdfminer.six`（已在 requirements）。
* Meilisearch 自动处理 typo-tolerance，无需在搜索端做 fuzziness 设置。
* 若需要高级排序、标注、或权限分层，我可以把 Flask 前端扩展为登陆系统并加注释功能（下一步）。

